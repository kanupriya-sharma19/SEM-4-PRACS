INSERTION

#include <stdio.h>

int arr[9]={2,-332,4,565,3,-1,-324,32432,32};
int n=9;
void insertionSort(int arr[], int n) {
    int i, key, j;
    for (i = 1; i < n; i++) {   
        j = i;
        while (j >0 && arr[j-1] >arr[j]) {
         int t=arr[j-1];
         arr[j-1]=arr[j];
         arr[j]=t;
         j--;
        }
        
    }
}

void printArray(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    
  

    insertionSort(arr, n);
printArray(arr,n);
    

    return 0;
}


SELECTION

#include<stdio.h>
#include<conio.h>

 
int arr[6]={2,-332,4,565,3,-1};
int n=6;
void printArray(int a[], int n){
    int i;
    for(i = 0; i < n; i++){
        printf("%d ", a[i]);
    }
    printf("\n");
}

void selectionSort(int a[], int n){
    int i, j, minIndex, temp;
    for(i = 0; i < n-1; i++){
        minIndex = i;
        for(j = i+1; j < n; j++){
            if(a[j] < a[minIndex]){
                minIndex = j;
            }
        }
        temp = a[i];
        a[i] = a[minIndex];
        a[minIndex] = temp;
    }
}

int main()
{
  
    selectionSort(arr, n);
printArray(arr,n);
    

    return 0;
}

MERGE

#include <stdio.h>

#define MAX_SIZE 1000

int temp[MAX_SIZE]; 

void merge(int arr[], int low, int mid, int high) {
    int left = low;
    int right = mid + 1;
    int k = 0;

    while (left <= mid && right <= high) {
        if (arr[left] <= arr[right]) {
            temp[k++] = arr[left++];
        } else {
            temp[k++] = arr[right++];
        }
    }

    while (left <= mid) {
        temp[k++] = arr[left++];
    }

    while (right <= high) {
        temp[k++] = arr[right++];
    }

    for (int i = 0; i < k; i++) {
        arr[low + i] = temp[i];
    }
}

void mergeSort(int arr[], int low, int high) {
    if (low >= high) return;
    int mid = (low + high) / 2;
    mergeSort(arr, low, mid);
    mergeSort(arr, mid + 1, high);
    merge(arr, low, mid, high);
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {2,-332,4,565,3,-1,-324,32432,32};
    int n = sizeof(arr) / sizeof(arr[0]);

    mergeSort(arr, 0, n - 1);

    printArray(arr, n);
    return 0;
}


QUICK

#include <stdio.h>

void swap(int* a, int* b) {
    int temp=*a;
    *a=*b;
    *b=temp;
}

int partition(int arr[], int low, int high) {
    int pivot = arr[low];
    int i = low;
    int j = high;

    while (i < j) {
        while (arr[i] <= pivot && i <= high - 1) {
            i++;
        }

        while (arr[j] > pivot && j >= low + 1) {
            j--;
        }

        if (i < j) {
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[low], &arr[j]);
    return j;
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pIndex = partition(arr, low, high);
        quickSort(arr, low, pIndex - 1);
        quickSort(arr, pIndex + 1, high);
    }
}

void printArray(int arr[], int n) {
    for (int i=0;i<n;i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[] = {4, 6, 2, 5, 7, 9, 1, 3};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Before Using Quick Sort:\n");
    printArray(arr, n);

    quickSort(arr, 0, n - 1);

    printf("After Using Quick Sort:\n");
    printArray(arr, n);

    return 0;
}


BINARY

#include <stdio.h>
#include <conio.h>

int binarySearch(int arr[], int n, int data) {
    int left = 0;
    int right = n - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == data) {
            return mid; 
        } else if (arr[mid] < data) {
            left = mid + 1; 
        } else {
            right = mid - 1; 
        }
    }

    return -1; 
}

int main() {
    int arr[10], n, i, data;

    printf("Enter the number of elements: ");
    scanf("%d", &n);

    printf("Enter the elements (in ascending order):\n");
    for (i = 0; i < n; i++)
        scanf("%d", &arr[i]);

    printf("Enter the element to be searched: ");
    scanf("%d", &data);

    int result = binarySearch(arr, n, data);

    if (result != -1)
        printf("%d found at position %d\n", data, result + 1);
    else
        printf("%d not found\n", data);

    return 0;
}


MIN MAX

#include<stdio.h>

int a[100], min, max;

void MinMax(int low, int high) {
	int mid, min1, max1;
	if (low == high) {
		max = min = a[low];
	}
	else if (low == high - 1) {
		if (a[low] < a[high]) {
			min = a[low];
			max = a[high];
		}
		else {
			min = a[high];
			max = a[low];
		}
	}
	else {
		mid = (low + high) / 2;
		MinMax(low, mid);
		min1 = min;
		max1 = max;
		MinMax(mid + 1, high);
		if (max1 > max)
			max = max1;
		if (min1 < min)
			min = min1;
	}
}

int main() {
	int i;
    int n;
    printf("Enter the number of elements: ");
    scanf("%d", &n);
	for (i = 0; i < n; i++)
    {
        printf("Enter element %d : ", i + 1);
		scanf("%d", &a[i]);
    }    
	MinMax(0, n - 1);
	printf("Min: %d, Max: %d", min, max);
	return 0;
}

LCS

#include <stdio.h>
#include <string.h>
void longest_common_subsequence_algorithm();
void print_sequence(int a, int b);
int a, b, c, d;
int temp[30][30];
char first_sequence[30], second_sequence[30], longest_sequence[30][30];
int main()
{
    printf("\nEnter the First String : ");
    scanf("%s", first_sequence);
    printf("\nEnter the Second String : ");
    scanf("%s", second_sequence);
    printf("\nLongest Common Subsequence : ");
    longest_common_subsequence_algorithm();
    print_sequence(c, d);
    printf("\n");
    return 0;
}
void longest_common_subsequence_algorithm()
{
    c = strlen(first_sequence);
    d = strlen(second_sequence);
    for (a = 0; a <= c; a++)
    {
        temp[a][0] = 0;
    }
    for (a = 0; a <= d; a++)
    {
        temp[0][a] = 0;
    }
    for (a = 1; a <= c; a++)
    {
        for (b = 1; b <= d; b++)
        {
            if (first_sequence[a - 1] == second_sequence[b - 1])
            {
                temp[a][b] = temp[a - 1][b - 1] + 1;
                longest_sequence[a][b] = 'c';
            }
            else if (temp[a - 1][b] >= temp[a][b - 1])
            {
                temp[a][b] = temp[a - 1][b];
                longest_sequence[a][b] = 'u';
            }
            else
            {
                temp[a][b] = temp[a][b - 1];
                longest_sequence[a][b] = 'l';
            }
        }
    }
}
void print_sequence(int a, int b)
{
    if (a == 0 || b == 0)
    {
        return;
    }
    if (longest_sequence[a][b] == 'c')
    {
        print_sequence(a - 1, b - 1);
        printf("%c", first_sequence[a - 1]);
    }
    else if (longest_sequence[a][b] == 'u')
    {
        print_sequence(a - 1, b);
    }
    else
    {
        print_sequence(a, b - 1);
    }
}


RABIN 
#include <stdio.h>
#include <string.h>

#define d 256

void search(char pattern[], char text[], int prime) {
    int pattern_length = strlen(pattern);
    int text_length = strlen(text);
    int i, j;
    int pattern_hash = 0; 
    int text_hash = 0; 
    int hash_multiplier = 1;

    for (i = 0; i < pattern_length - 1; i++)
        hash_multiplier = (hash_multiplier * d) % prime;

    for (i = 0; i < pattern_length; i++) {
        pattern_hash = (d * pattern_hash + pattern[i]) % prime;
        text_hash = (d * text_hash + text[i]) % prime;
    }

    for (i = 0; i <= text_length - pattern_length; i++) {
        if (pattern_hash == text_hash) {
            for (j = 0; j < pattern_length; j++) {
                if (text[i + j] != pattern[j])
                    break;
            }
            if (j == pattern_length)
                printf("Pattern found at index %d \n", i);
        }
 
        if (i < text_length - pattern_length) {
            text_hash = (d * (text_hash - text[i] * hash_multiplier) + text[i + pattern_length]) % prime;
            if (text_hash < 0)
                text_hash = (text_hash + prime);
        }
    }
}

int main() {
    char text[100], pattern[100];
    int prime=7393;

    printf("Enter the text: ");
    scanf("%s", text);

    printf("Enter the pattern: ");
    scanf("%s", pattern);

    

    search(pattern, text, prime);
    return 0;
}


KMP

#include <stdio.h>
#include <string.h>

void prefixSuffixArray(char pat[], int M, int pps[])
{
    int length = 0;
    pps[0] = 0;
    int i = 1;
    while (i < M)
    {
        if (pat[i] == pat[length])
        {
            length++;
            pps[i] = length;
            i++;
        }
        else
        {
            if (length != 0)
                length = pps[length - 1];
            else
            {
                pps[i] = 0;
                i++;
            }
        }
    }
}
void KMPAlgorithm(char text[], char pattern[])
{
    int M = strlen(pattern);
    int N = strlen(text);
    int pps[M];
    prefixSuffixArray(pattern, M, pps);
    int i = 0;
    int j = 0;
    while (i < N)
    {
        if (pattern[j] == text[i])
        {
            j++;
            i++;
        }
        if (j == M)
        {
            printf("Found pattern at index %d\n", i - j);
            j = pps[j - 1];
        }
        else if (i < N && pattern[j] != text[i])
        {
            if (j != 0)
                j = pps[j - 1];
            else
                i = i + 1;
        }
    }
}
int main()
{
    char text[] = "xyztrwqxyzfg";
    char pattern[] = "xyz";
    printf("The pattern is found in the text at the following index : \n");
    KMPAlgorithm(text, pattern);
    return 0;
}